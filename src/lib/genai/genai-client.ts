import { neo4jDriver } from '@/lib/drivers/neo4j-driver'

export interface GenAICypherRequest {
  naturalLanguageQuery: string
  schema?: string
  context?: Record<string, any>
}

export interface GenAICypherResponse {
  cypher: string
  explanation?: string
  confidence?: number
}

export class GenAIClient {
  private useLocalLLM: boolean = true

  async generateCypher(request: GenAICypherRequest): Promise<GenAICypherResponse> {
    if (this.useLocalLLM) {
      return this.generateCypherWithSparkLLM(request)
    } else {
      return this.generateCypherWithNeo4jPlugin(request)
    }
  }

  private async generateCypherWithSparkLLM(request: GenAICypherRequest): Promise<GenAICypherResponse> {
    const prompt = (window as any).spark.llmPrompt`
You are a Neo4j Cypher query expert. Generate a valid Cypher query based on the following natural language request:

Natural Language Query: ${request.naturalLanguageQuery}

${request.schema ? `Database Schema:\n${request.schema}` : ''}

${request.context ? `Additional Context:\n${JSON.stringify(request.context, null, 2)}` : ''}

Generate a valid, executable Cypher query that answers this request. Return ONLY the Cypher query without any explanations, markdown formatting, or additional text.

Important rules:
- Use proper Cypher syntax
- Use MATCH clauses for reading data
- Use CREATE/MERGE for writing data
- Use WHERE clauses for filtering
- Use RETURN to specify what to return
- Do not include markdown code blocks or backticks
- Do not include any explanatory text

Cypher Query:`

    try {
      const response = await (window as any).spark.llm(prompt, 'gpt-4o')
      
      let cypher = response.trim()
      cypher = cypher.replace(/^```cypher\s*/gm, '')
      cypher = cypher.replace(/^```\s*/gm, '')
      cypher = cypher.replace(/```$/gm, '')
      cypher = cypher.trim()

      return {
        cypher,
        explanation: 'Generated using Spark LLM',
        confidence: 0.85
      }
    } catch (error) {
      console.error('GenAI: Cypher generation failed', error)
      throw new Error('Failed to generate Cypher query')
    }
  }

  private async generateCypherWithNeo4jPlugin(request: GenAICypherRequest): Promise<GenAICypherResponse> {
    if (!neo4jDriver.isConnected()) {
      throw new Error('Neo4j driver not connected. Cannot use GenAI plugin.')
    }

    try {
      const cypher = `
        CALL genai.cypher.generate($naturalLanguageQuery, $context) 
        YIELD cypher, confidence
        RETURN cypher, confidence
      `

      const result = await neo4jDriver.executeQuery(cypher, {
        naturalLanguageQuery: request.naturalLanguageQuery,
        context: request.context || {}
      })

      if (result.records.length > 0) {
        const record = result.records[0]
        return {
          cypher: record.get('cypher'),
          confidence: record.get('confidence'),
          explanation: 'Generated using Neo4j GenAI plugin'
        }
      }

      throw new Error('No Cypher query generated by Neo4j plugin')
    } catch (error) {
      console.warn('GenAI Plugin not available, falling back to Spark LLM', error)
      return this.generateCypherWithSparkLLM(request)
    }
  }

  async executeCypherFromNL(naturalLanguageQuery: string, context?: Record<string, any>) {
    const cypherResponse = await this.generateCypher({
      naturalLanguageQuery,
      context
    })

    if (!neo4jDriver.isConnected()) {
      throw new Error('Neo4j driver not connected. Cannot execute query.')
    }

    console.log('Generated Cypher:', cypherResponse.cypher)

    const result = await neo4jDriver.executeQuery(cypherResponse.cypher)

    return {
      ...result,
      generatedCypher: cypherResponse.cypher,
      explanation: cypherResponse.explanation
    }
  }

  setUseLocalLLM(enabled: boolean) {
    this.useLocalLLM = enabled
  }

  isUsingLocalLLM(): boolean {
    return this.useLocalLLM
  }
}

export const genAIClient = new GenAIClient()
